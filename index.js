'use strict';

const crypto = require('crypto'),
      stream = require('stream');

function toBytes(obj) {
  if (typeof obj === 'string') {
    return Buffer.from(obj, 'base64');
  } else if (obj instanceof Buffer) {
    return obj;
  }

  throw new Error('Cannot convert to bytes');
}

const BLOCK_LENGTH = 16;
const DEFAULT_CIPHER = 'aes-256-cbc';

class EncryptStream extends stream.Transform {
  constructor(opts) {
    super(opts);

    const cipherName = opts.cipherName || DEFAULT_CIPHER;
    const key = toBytes(opts.key);
    const iv = crypto.randomBytes(BLOCK_LENGTH);
    this._cipher = crypto.createCipheriv(cipherName, key, iv);
    this.push(iv);
  }

  _transform(chunk, enc, cb) {
    this.push(this._cipher.update(chunk));
    cb();
  }

  _flush(cb) {
    this.push(this._cipher.final());
    cb();
  }

  static getEncryptedLength(length) {
    const diff = length % BLOCK_LENGTH;
    // If diff is 0, an entire BLOCK_LENGTH worth of padding will be added.
    const paddingLength = diff === 0 ? BLOCK_LENGTH : (BLOCK_LENGTH - diff);
    // Initial IV at the beginning.
    const ivLength = BLOCK_LENGTH;
    return length + ivLength + paddingLength;
  }
}

const STATE_READ_IV = 0,
      STATE_SKIP_PREFIX = 1,
      STATE_READING = 2,
      STATE_SKIP_SUFFIX = 3;

class DecryptStream extends stream.Transform {
  constructor(opts) {
    super(opts);

    this._cipherName = opts.cipherName || DEFAULT_CIPHER;

    // The caller is responsible to make sure that any passed in stream
    // are at block boundaries.
    // So, we allow skipping prefix and suffix bytes to get the exact
    // wanted range.
    // In addition, for the case where the input stream is a complete
    // stream generated by EncryptStream, the final bytes are going
    // to be padding. So because we setAutoPadding(false) below, the
    // decrypted data would include the padding bytes.
    // One option was to setAutoPadding(true) when we know we will
    // hit the end of the stream, but that still doesn't solve
    // the case of skipping suffix bytes.
    this._skipPrefixLength = opts.skipPrefixLength || 0;
    if (isNaN(this._skipPrefixLength) || this._skipPrefixLength < 0) {
      throw new Error('Invalid skip prefix length');
    }

    if (isNaN(opts.wantedOutputLength) || opts.wantedOutputLength <= 0) {
      throw new Error('Unknown wanted length');
    }
    this._wantedLength = opts.wantedOutputLength;
    this._currentLength = 0;

    const key = toBytes(opts.key);
    if (opts.iv) {
      const iv = toBytes(opts.iv);
      this._state = this._skipPrefixLength ? STATE_SKIP_PREFIX : STATE_READING;
      this._key = null;
      this._iv = null;
      this._ivBytesRemaining = 0;
      this._decipher = crypto.createDecipheriv(this._cipherName, key, iv);
      this._decipher.setAutoPadding(false);
    } else {
      this._state = STATE_READ_IV;
      this._key = key;
      this._iv = Buffer.allocUnsafe(BLOCK_LENGTH);
      this._ivBytesRemaining = BLOCK_LENGTH;
      this._decipher = null;
    }
  }

  _transform(chunk, enc, cb) {
    if (this._state === STATE_READ_IV) {
      const chunkLength = chunk.length;
      const takeLength = Math.min(this._ivBytesRemaining, chunkLength);
      const ivStartOffset = BLOCK_LENGTH - this._ivBytesRemaining;

      chunk.copy(this._iv, ivStartOffset, 0, takeLength);
      this._ivBytesRemaining -= takeLength;

      if (this._ivBytesRemaining === 0) {
        this._decipher = crypto.createDecipheriv(this._cipherName, this._key, this._iv);
        this._decipher.setAutoPadding(false);
        this._key = null;
        this._iv = null;

        this._state = this._skipPrefixLength ? STATE_SKIP_PREFIX : STATE_READING;
        if (chunkLength > takeLength) {
          return this._transform(chunk.slice(takeLength), enc, cb);
        }
      }
    } else if (this._state === STATE_SKIP_PREFIX) {
      const decrypted = this._decipher.update(chunk);
      const decryptedLength = decrypted.length;
      if (decryptedLength < this._skipPrefixLength) {
        this._skipPrefixLength -= decryptedLength;
      } else {
        const unusedLength = decryptedLength - this._skipPrefixLength;
        this._skipPrefixLength = 0;
        this._state = STATE_READING;
        if (unusedLength > 0) {
          return this._handleReading(decrypted.slice(decryptedLength - unusedLength), cb);
        }
      }
    } else if (this._state === STATE_READING) {
      return this._handleReading(this._decipher.update(chunk), cb);
    } else if (this._state === STATE_SKIP_SUFFIX) {
      // No-op.
    } else {
      throw new Error('Unknown state: ' + this._state);
    }

    cb();
  }

  _handleReading(decryptedChunk, cb) {
    const length = decryptedChunk.length;
    this._currentLength += length;
    if (this._currentLength <= this._wantedLength) {
      this.push(decryptedChunk);
    } else {
      const extraLength = this._currentLength - this._wantedLength;
      this.push(decryptedChunk.slice(0, decryptedChunk.length - extraLength));
      this._state = STATE_SKIP_SUFFIX;
    }
    cb();
  }

  _flush(cb) {
    if (this._state === STATE_READING) {
      // It's possible that the stream can close without the input being
      // piped in full, which can cause final() to throw.
      let finalChunk;
      try {
        finalChunk = this._decipher.final();
      } catch (err) {
        return cb(err);
      }
      if (finalChunk.length) {
        return this._handleReading(finalChunk, cb);
      }
    }
    cb();
  }

  static calculateParams({ decryptedStartIndex, decryptedEndIndex }) {
    const desiredLength = decryptedEndIndex - decryptedStartIndex + 1;

    // Start from a block boundary.
    // We don't have to offset the start index to account for the IV, because
    // encrypted stream prefixes BLOCK_LENGTH bytes for the IV.
    // So, encryptedStartIndex will be pointing at the IV.
    const skipPrefixLength = decryptedStartIndex % BLOCK_LENGTH;
    const encryptedStartIndex = decryptedStartIndex - skipPrefixLength;

    // + skipPrefixLength for the skipped decrypted bytes.
    // + BLOCK_LENGTH for the IV.
    let encryptedLength = desiredLength + skipPrefixLength + BLOCK_LENGTH;

    // Make sure to end on a block boundary.
    if ((encryptedLength % BLOCK_LENGTH) !== 0) {
      encryptedLength += BLOCK_LENGTH - (encryptedLength % BLOCK_LENGTH);
    }

    return {
      skipPrefixLength,
      encryptedStartIndex,
      encryptedEndIndex: encryptedStartIndex + encryptedLength - 1,
      wantedOutputLength: desiredLength
    };
  }
}

module.exports = { EncryptStream, DecryptStream, BLOCK_LENGTH };
